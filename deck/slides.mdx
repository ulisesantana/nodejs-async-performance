import {Steps, Footer, Notes} from 'mdx-deck'
import {
  Code,
  ProfileImage,
  LeanMind,
  Row,
  GlobalStyle,
  FluidContainer,
  Footer as SlideFooter
} from "./components";

import nodeJsLogo from "./assets/images/node-js-logo.svg"
import lumberjackImage from "./assets/images/lumberjack.jpeg"
import ulises from "./assets/images/ulises.jpeg"
import matteo from "./assets/images/matteo.jpg"
import james from "./assets/images/james.jpg"
import mocha from "./assets/images/mocha-puppy.jpg"
import nullTheCat from "./assets/images/null.jpg"
import mochaAndNull from "./assets/images/mocha-and-null.jpg"
import cjsToESM from "./assets/images/cjs-to-esm.png"
import awaitLoop from "./assets/images/await-loop.png"
import promiseAll from "./assets/images/promise-all.png"

import coffinDance from "./assets/gifs/coffin-dance.gif"
import sheldonBag from "./assets/gifs/sheldon-bag.gif"
import pickleRick from "./assets/gifs/pickle-rick.gif"
import dude from "./assets/gifs/fuck-yeah-dude.gif"

import uselessAsync from "./assets/screenshots/useless-async.png"
import asyncLoop from "./assets/screenshots/async-loop.png"
import cachedPromises from "./assets/screenshots/cached-promises.png"

export const theme = {
  styles: GlobalStyle
}

<Footer>
  <SlideFooter/>
</Footer>

## Cómo pasé un proceso en

<img
  src={nodeJsLogo}
  style={{height: '30vmin'}}
  alt="Node.js logo"
/>

## de 5 horas a 5 minutos
---

<FluidContainer style={{
  alignContent: 'center',
  justifyContent: 'space-around' ,
  textAlign: 'right',
  width: '100%'
}}>

  <div style={{
    alignItems: 'start',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center'
  }}>

  # Ulises Santana

  Full Stack Developer en

  <LeanMind size="250px"/>

  </div>

  <div style={{
    alignItems: 'center',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center'
  }}>

  <ProfileImage
    src={ulises}
    size="50vmin"
    alt="Foto de Ulises Santana"
  />

  # ulisesantana.dev

  </div>

</FluidContainer>


<Notes>

- LeanMind nos integramos en otros equipos para ayudarles a que sus proyectos sean sostenibles.
- Twitter & Github en la parte inferior de cada diapositiva.
- Mi blog.
- Soy de GC, pero me mudé a El Hierro.

</Notes>

---

<Row alignCenter>
  <img
    src={mocha}
    alt="Mi perra Mocha"
    style={{height: '40vmin', transform: 'rotate(-15deg)'}}
  />
  <img
    src={nullTheCat}
    alt="Mi gato Null"
    style={{height: '40vmin', transform: 'rotate(15deg)'}}
  />
</Row>

<img
  src={mochaAndNull}
  alt="Mocha y Null siendo felices"
  style={{height: '40vmin'}}
/>

---

# Contexto

<Steps>

1. No todo el equipo controlaba la tecnología en la que se estaba trabajando.
1. El deadline es fijo y crítico, ya que rompemos el cash flow de la empresa en caso de retrasarnos.

</Steps>

<Notes>

- ¿Cómo era el equipo? 5 personas.
- El deadline

</Notes>

---

# *Dame 6 horas para cortar un árbol y pasaré 4 afilando el hacha*

<Notes>

- A Abraham Lincoln se le atribuye esta frase
- ¿En qué estado estaba el prototipo?
- Nos dieron luz verde para rehacer de cero el prototipo. 

</Notes>

---

## El Proyecto Leñador

<img
  src={lumberjackImage}
  alt="Ulises vestido de leñador con hacha en mano"
  style={{height: '50vmin'}}
/>

<Notes>

- El gobierno no confirmó hasta 3 meses antes. 
- El reparto de los proyectos 
- Descuido del proceso de code review por sobrecarga
- ¿Quién hizo el Proyecto Leñador?
- Comparación de legibilidad entre Proyecto Leñador y prototipo
- Última review con posibles problemas de performance

</Notes>

---

## Prototipo original:

~7 minutos

<Steps>
  <div>
    <h2>Proyecto Leñador:</h2>
    <p
      style={{
        color: 'red',
        fontWeight: 'bold',
        textDecoration: "underline"
      }}
    >
      5 horas 7 minutos y 54 segundos
    </p>
  </div>
</Steps>

<Notes>

- Hicimos una prueba con unos cientos de miles de registros.

</Notes>

---

<h1
  style={{
    fontSize: '20vw',
    color: 'red'
  }}
>
  + 4400%
</h1>

<Notes>

- En producción de 40 minutos a 29 horas y 20 minutos

</Notes>

---
<img
  src={coffinDance}
  alt="Gif de los bailarines del ataúd (Coffin dance)"
  style={{
    width: '80vw'
  }}
/>


---

# Deadline: 10 días

<Steps>
  <h1 style={{textDecoration: 'underline'}}>NATURALES</h1>
</Steps>

<Notes>

- El proyecto no se podía replantear
- Habían otros 4 proyectos
- Llevo toda mi vida preparándome para este momento, los talleres sobre asincronía en Node.js con Matteo Collina y James Snell van a dar sus frutos

</Notes>

---

<FluidContainer>
  <div>
    <ProfileImage
      src={matteo}
      alt="Foto de Matteo Collina"
      size="60vmin"
    />

  ## @matteocollina

  </div>

  <div>
    <ProfileImage
      src={james}
      alt="Foto de James Snell"
      size="60vmin"
    />

  ## @jasnell

  </div>
</FluidContainer>

<Notes>

- Volviendo a la historia, en ese momento una parte de mí era una mezcla de esto.

</Notes>

---

<FluidContainer>
  <img
    src={sheldonBag}
    alt="Gif de Sheldon respirando en una bolsa de papel"
    style={{
      width: '45vw'
    }}
  />
  <img
    src={pickleRick}
    alt="Gif de Pickle Rick agonizando bajo el sol"
    style={{
      width: '35vw'
    }}
  />
</FluidContainer>

<Notes>

- Entré en modo pánico y empecé a refactorizar
- Tras este refactor vi ciertos patrones que quiero remarcar y mostrar cómo podemos darles la vuelta para convertirlos en best practices.

</Notes>

---

# 1. Evita async innecesarios

---

<Code>

  ```js
  export function randomNumber() {
      return Math.random()
  }

  export async function asyncRandomNumber() {
      return Math.random()
  }
  ```

  ```diff 5[7:13]
  ```

</Code>

<Notes>

- Hice una pequeña demo para demostrar hasta qué punto esto afecta a nuestro performance. Lo que hace el script es ejecutar cada una de estas funciones por separado un millón de veces.

</Notes>

---

<img
  src={uselessAsync}
  alt="Resultado demo useless-async"
/>

---

<Code>

```js
describe('This feature should', () => {
  it('do stuff', async () => {
    //test...
  })

  it('do more stuff', async () => {
    //test...
  })
})
```

```diff 2[18:23],6[23:28]
```

</Code>

<Notes>

- Pasamos de 2:10 a 1:30 quitando los async.

</Notes>

---

# 2. Evita los await dentro de los bucles

<Notes>

- Este consejo es el buque insignia de esta charla
- En base a una lista de IDs tienes que recuperar información de una API
- La API no acepta listas, sino que tienes que pedirlos de uno en uno.
- ¿Cuál sería la primera solución que se nos vendría a la cabeza?

</Notes>

---

<Code>

  ```js
  async function fetchUserListInfo(ids) {
    const values = []
    for (const id of ids) {
      values.push(await fetchUserInfo(id))
    }
    return values
  }
  ```


</Code>

---

<img
  src={awaitLoop}
  alt="Como se resuelven las promesas usando un await dentro de un bucle"
/>

---

<Code>

  ```js
  function fetchUserListInfo(ids) {
    const values = []
    for (const id of ids) {
      values.push(fetchUserInfo(id))
    }
    return Promise.all(values)
  }
  ```

  ```diff 1
  ```

  ```diff 4
  ```

  ```diff 6
  ```

</Code>

<Notes>

- ¿Qué es lo que hay en ese Array? Promesas de Schrodinger

</Notes>

---

<img
  src={promiseAll}
  alt="Como se resuelven las promesas usando Promise.all"
/>

---

<img
  src={asyncLoop}
  alt="Resultado demo async-loop"
/>

<Notes>

- Puedes acabar haciéndote un ataque de denegación de servicio al bloquear el event loop.

</Notes>

---

<Code>

  ```ts
  async function fetchUserInfo(id): User {
    try {
      const response = await fetch('https://api.awesome-project.com/user/' + id)
      return User.fromResponse(response)
    } catch(err) {
      console.error('Error fetching user:', id)
      console.error(err.message)
      console.error(err.stack)
      return new NullUser()
    }
  }
  ```

  ```diff 1[32:39],2,4,5,9,10
  ```

</Code>

<Notes>

- Si una promesa falla, se aborta el Promise.all, dejando promesas a medio.
- En el ejemplo se devuelve siempre algo con lo que se pueda trabajar
- En el mundo real ese array habría que filtrarlo antes de empezar a trabajar con él.

</Notes>

---

<Code>

  ```ts
  type PromiseAllSettleReturnValue<T> = Array<{
    status: 'fulfilled' | 'rejected',
    value?: T,
    reason?: Error
  }>
  ```

  ```diff 2[1:21],3
  ```

  ```diff 2[1:10,24:33],4
  ```

</Code>

<Notes>

- Aquí igualmente hay que gestionar el array antes de usarlo.

</Notes>

---

# 3. Usa Promise.all siempre que puedas

---

<Code>

  ```js
  async function readAllUserInfo(userId) {
    const user = await readUser(userId)
    const contracts = await readContractsForUser(userId)
    const invoices = await readInvoicesForUser(userId)
    return {
      ...user,
      contracts,
      invoices
    }
  }
  ```

  ```js
  async function readAllUserInfo(userId) {
    const [ user, contracts, invoices ] = await Promise.all([
      readUser(userId),
      readContractsForUser(userId),
      readInvoicesForUser(userId)
    ])
    return {
      ...user,
      contracts,
      invoices
    }
  }
  ```

</Code>

---

<FluidContainer>

<img
  src={awaitLoop}
  alt="Como se resuelven las promesas usando un await dentro de un bucle"
  style={{
    height: '30vh'
  }}
/>

<img
  src={promiseAll}
  alt="Como se resuelven las promesas usando Promise.all"
  style={{
    height: '30vh'
  }}
/>

</FluidContainer>

<Notes>

- Usar Promise.all es muy goloso, por eso tienes que ser consciente de cuantas promesas estás gestionando.

</Notes>

---

# 4. Sé consciente de cuantas promesas estás gestionando

---

<Code>

```js
function fetchUserListInfo(ids) {
  return Promise.all(ids.map(fetchUserInfo))
}
```

```js
import pMap from 'p-map';

function fetchUserListInfo(ids) {
  return pMap(
    ids,
    fetchUserInfo,
    {concurrency: 10}
  )
}
```

</Code>

<Notes>

- No sabes cuantos IDS te van a pasar. Te podrías hacer un ataque de denegación de servicio a ti mismo.
- La concurrency que usábamos era el límite de conexiones de base de datos.

</Notes>

---

<img
  src={cjsToESM}
  alt="De CommonJS a ES Modules"
/>

<Notes>

- Usas CommonJS -> version 4 
- Usas ESM -> version 5 

</Notes>

---

# 5. Haz caso de los warnings

---

<Code>

  ```shell
  (node) warning: possible EventEmitter memory leak detected.
  11 listeners added.
  Use emitter.setMaxListeners() to increase limit.
  ```

</Code>

<Notes>

- Que levante la mano el que ha ignorado un warning.
- El problema era que había event handlers que se estaban creando continuamente con cada conexión que se solicitaba al pool de conexiones de la base de datos, pero que no se estaban eliminando, siendo el causante del memory leak. Tras implementar el fix en el que cada vez que se devuelve una conexión al pool se limpian los event handlers asociados a la conexión vimos una mejoría en la performance, tardando 4 veces menos de lo que tardaba antes.

</Notes>

---

## Prototipo original:

~7 minutos

<Steps>
  <div>
    <h2>Proyecto Leñador:</h2>
    <p
      style={{
        color: 'green',
        fontWeight: 'bold'
      }}
    >
      4 minutos y 52 segundos
    </p>
  </div>
</Steps>


<Notes>

- Cuando vi el resultado me sentí tal que así

</Notes>

---

<img
  src={dude}
  alt="La vida puede ser maravillosa cuando todo funciona"
  style={{
    width: '60vw'
  }}
/>

<Notes>

- No sabía si era de día o de noche, pero fue épico.

</Notes>

---

## Prototipo original:

41 minutos y 29 segundos

<Steps>
  <div>
    <h2>Proyecto Leñador:</h2>
    <p
      style={{
        color: 'green',
        fontWeight: 'bold'
      }}
    >
      31 minutos y 56 segundos
    </p>
  </div>
</Steps>

---

<h1
  style={{
    fontSize: '20vw',
    color: 'green'
  }}
>
  - 20%
</h1>

---

# Aprendizaje

<Steps>

  1. La asincronía en JS está más incomprendida de lo que pensaba
  1. Forma a tu equipo
  1. La responsabilidad debe ser compartida
  1. Sé prescindible

</Steps>

---

# Cómo gestionar asincronía en JavaScript

<Steps>

  1. Evita los async innecesarios
  1. Evita los await dentro de los bucles
  1. Usa Promise.all siempre que puedas
  1. Sé consciente de cuantas promesas estás gestionando
  1. No ignores los warnings

</Steps>

---

# Bonus tips


<Steps>

  1. No mezcles tipos de asincronía
  1. Descubre los async generators
  1. Investiga sobre el Event Loop

</Steps>

---

# Recursos

- Charla sobre async generators: **bit.ly/async-generators-talk**
- Guía sobre el Event Loop en Node.js: **bit.ly/nodejs-event-loop**
- Artículo sobre gestión de promesas en Node.js: **bit.ly/broken-promises-post**

---

# ¡Gracias!

## bit.ly/nodejs-async-performance-slides
## bit.ly/nodejs-async-performance-post
